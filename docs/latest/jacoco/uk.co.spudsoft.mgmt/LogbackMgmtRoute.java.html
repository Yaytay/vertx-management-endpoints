<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogbackMgmtRoute.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Vertx Management Endpoints</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.mgmt</a> &gt; <span class="el_source">LogbackMgmtRoute.java</span></div><h1>LogbackMgmtRoute.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2022 jtalbut
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package uk.co.spudsoft.mgmt;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.Appender;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.MIMEHeader;
import io.vertx.ext.web.ParsedHeaderValue;
import io.vertx.ext.web.ParsedHeaderValues;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.impl.ParsableMIMEValue;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A Vertx HTTP Server route for allowing users to pull and update logback levels.
 *
 * It is strongly recommended that this endpoint be mounted on via a subrouter, the path to which is only accessible from authorised personnel.
 * The integration tests demonstrate the use of a suitable subrouter to locate the endpoint at /manage/logback.
 *
 * Two routes are created:
 * &lt;ul&gt;
 * &lt;LI&gt;GET /logback
 * Downloads a JSON representation of all the registered loggers.
 * If the request specifies an Accept header of &quot;text/html&quot; (before any specification of &quot;application/json&quot;) downloads a single HTML page that provides the ability to change log levels via a UI.
 * &lt;LI&gt;PUT /logback/:logger
 * Requires a message body that contains a JSON object with a single element (&quot;level&quot;) with a value that is (case insensitive) a valid Logback level.
 * The level of the specified logger is changed to the specified level.
 * &lt;/ul&gt;
 * 
 * @author jtalbut
 */
public class LogbackMgmtRoute implements Handler&lt;RoutingContext&gt; {

  /**
   * The path at which the standardDeploy method will put the router.
   */
  public static final String PATH = &quot;logback&quot;;

  @SuppressWarnings(&quot;constantname&quot;)
<span class="fc" id="L71">  private static final Logger logger = LoggerFactory.getLogger(LogbackMgmtRoute.class);</span>

<span class="fc" id="L73">  private static final ParsedHeaderValue HTML = new ParsableMIMEValue(&quot;text/html&quot;);</span>
<span class="fc" id="L74">  private static final ParsedHeaderValue JSON = new ParsableMIMEValue(&quot;application/json&quot;);</span>
  
  private String htmlContents;    

  /**
   * Constructor.
   */
<span class="fc" id="L81">  public LogbackMgmtRoute() {</span>
<span class="fc" id="L82">  }</span>
  
  /**
   * Deploy the route to the router passed in at the normal endpoint.
   * 
   * The router passed in should be a sub router that is inaccessible to normal users.
   * 
   * @param router The router that this handler will be attached to.
   */
  public void standardDeploy(Router router) {
<span class="fc" id="L92">    router.route(HttpMethod.GET, &quot;/&quot; + PATH).handler(this::handle).setName(&quot;Logback Management&quot;);</span>
<span class="fc" id="L93">    router.route(HttpMethod.PUT, &quot;/&quot; + PATH + &quot;/:logger&quot;).handler(this::handle).setName(&quot;Logback Management&quot;);</span>
<span class="fc" id="L94">  }</span>
  
  /**
   * Factory method to do standard deployment on newly constructed route.
   * 
   * The router passed in should be a sub router that is inaccessible to normal users.
   * 
   * @param router The router that this handler will be attached to.
   */
  public static void createAndDeploy(Router router) {
<span class="fc" id="L104">    LogbackMgmtRoute route = new LogbackMgmtRoute();</span>
<span class="fc" id="L105">    route.standardDeploy(router);</span>
<span class="fc" id="L106">  }</span>

  
  @Override
  public void handle(RoutingContext event) {
<span class="fc" id="L111">    HttpServerRequest request = event.request();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (request.method() == HttpMethod.GET) {</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">      if (wantsHtml(event)) {</span>
<span class="fc" id="L114">        getHtml(request, event.response());</span>
      } else {
<span class="fc" id="L116">        getLogLevelsJson(event.response());</span>
      }
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    } else if (request.method() == HttpMethod.PUT) {</span>
<span class="fc" id="L119">      updateLogLevel(event.pathParam(&quot;logger&quot;), request, event.response());</span>
    } else {
<span class="nc" id="L121">      event.next();</span>
    }
<span class="fc" id="L123">  }</span>
  
  static boolean wantsHtml(RoutingContext event) {
    try {
<span class="fc" id="L127">      ParsedHeaderValues phv = event.parsedHeaders();</span>
<span class="fc" id="L128">      List&lt;MIMEHeader&gt; types = phv.accept();</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">      for (MIMEHeader type : types) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (type.isMatchedBy(JSON)) {</span>
<span class="fc" id="L131">          return false;</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        } else if (type.isMatchedBy(HTML)) {</span>
<span class="fc" id="L133">          return true;</span>
        }
<span class="nc" id="L135">      }    </span>
<span class="nc" id="L136">      return false;</span>
<span class="nc" id="L137">    } catch (Throwable ex) {</span>
<span class="nc" id="L138">      logger.debug(&quot;Failed to determine whether request wants HTML: &quot;, ex);</span>
<span class="nc" id="L139">      return false;</span>
    }
  }

  /**
   * Get the current log levels as a JsonObject.
   * 
   * This does the bulk of the work of verticle.
   * 
   * @return the current log levels as a JsonObject.
   */
  public static JsonObject getLogLevels() {
<span class="fc" id="L151">    LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</span>
<span class="fc" id="L152">    JsonObject json = new JsonObject();</span>

<span class="fc" id="L154">    JsonObject appenders = new JsonObject();</span>
<span class="fc" id="L155">    json.put(&quot;appenders&quot;, appenders);</span>
<span class="fc" id="L156">    JsonObject loggers = new JsonObject();</span>
<span class="fc" id="L157">    json.put(&quot;loggers&quot;, loggers);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">    for (ch.qos.logback.classic.Logger curLogger : loggerContext.getLoggerList()) {</span>
<span class="fc" id="L159">      Iterator&lt;Appender&lt;ILoggingEvent&gt;&gt; appenderIterator = curLogger.iteratorForAppenders();</span>
<span class="fc" id="L160">      List&lt;String&gt; appendersForLogger = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">      while (appenderIterator.hasNext()) {</span>
<span class="fc" id="L162">        Appender&lt;ILoggingEvent&gt; appender = appenderIterator.next();</span>
<span class="fc" id="L163">        appendersForLogger.add(appender.getName());</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (!appenders.containsKey(appender.getName())) {</span>
<span class="fc" id="L165">          JsonObject jsonAppender = new JsonObject();</span>
<span class="fc" id="L166">          jsonAppender.put(&quot;name&quot;, appender.getName());</span>
<span class="fc" id="L167">          jsonAppender.put(&quot;type&quot;, appender.getClass().toString());</span>
<span class="fc" id="L168">          jsonAppender.put(&quot;started&quot;, appender.isStarted());</span>
<span class="fc" id="L169">          appenders.put(appender.getName(), jsonAppender);</span>
        }
<span class="fc" id="L171">      }</span>
<span class="fc" id="L172">      JsonObject jsonLogger = new JsonObject();</span>
<span class="fc" id="L173">      jsonLogger.put(&quot;name&quot;, curLogger.getName());</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">      if (curLogger.getLevel() != null) {</span>
<span class="fc" id="L175">        jsonLogger.put(&quot;level&quot;, curLogger.getLevel().levelStr);</span>
      }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">      if (curLogger.getEffectiveLevel() != null) {</span>
<span class="fc" id="L178">        jsonLogger.put(&quot;effectiveLevel&quot;, curLogger.getEffectiveLevel().levelStr);</span>
      }
<span class="fc" id="L180">      jsonLogger.put(&quot;additive&quot;, curLogger.isAdditive());</span>
<span class="fc" id="L181">      jsonLogger.put(&quot;appenders&quot;, appendersForLogger);</span>
<span class="fc" id="L182">      loggers.put(curLogger.getName(), jsonLogger);</span>
<span class="fc" id="L183">    }</span>
    
<span class="fc" id="L185">    return json;</span>
  }

  /**
   * Set the level of the specified logger.
   * 
   * This will only do anything if the LoggerFactory returns a Logback LoggerContext that contains a Logger with the specified name.
   * This prevents a caller from creating new Loggers.
   * 
   * @param loggerName The name of the Logger to be adjusted.
   * @param levelName The desired target level (will default to Debug if not recognised as a valid level).
   */
  public static void setLogLevel(String loggerName, String levelName) {
<span class="fc" id="L198">    Object loggerFactory = LoggerFactory.getILoggerFactory();</span>
<span class="fc" id="L199">    ch.qos.logback.classic.Logger lg = null;</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (loggerFactory instanceof LoggerContext) {</span>
<span class="fc" id="L201">      LoggerContext lc = (LoggerContext) loggerFactory;</span>
<span class="fc" id="L202">      lg = lc.exists(loggerName);</span>
    }
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (lg != null) {</span>
<span class="fc" id="L205">      Level level = Level.toLevel(levelName);</span>
<span class="fc" id="L206">      logger.info(&quot;Changing {} log level to {}&quot;, lg, level);</span>
<span class="fc" id="L207">      lg.setLevel(level);</span>
<span class="fc" id="L208">    } else {</span>
<span class="fc" id="L209">      logger.info(&quot;Not changing the level of {} because it does not already exist&quot;, loggerName);</span>
    }
<span class="fc" id="L211">  }</span>
  
  private void getLogLevelsJson(HttpServerResponse response) {
    try {
<span class="fc" id="L215">      JsonObject json = getLogLevels();</span>
<span class="fc" id="L216">      response.putHeader(HttpHeaderNames.CONTENT_TYPE, &quot;application/json&quot;);</span>
<span class="fc" id="L217">      response.setStatusCode(200);</span>
<span class="fc" id="L218">      response.end(json.toBuffer());</span>
<span class="nc" id="L219">    } catch (Throwable ex) {</span>
<span class="nc" id="L220">      logger.error(&quot;Failed to get logback configuration: &quot;, ex);</span>
<span class="nc" id="L221">      response.setStatusCode(500);</span>
<span class="nc" id="L222">      response.end();</span>
<span class="fc" id="L223">    }</span>
<span class="fc" id="L224">  }</span>
  
  private void getHtml(HttpServerRequest request, HttpServerResponse response) {
<span class="fc" id="L227">    Future&lt;String&gt; loadFuture = Future.succeededFuture(htmlContents);</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (loadFuture.result() == null) {</span>
<span class="fc" id="L229">      loadFuture = Vertx.currentContext().executeBlocking(promise -&gt; {</span>
<span class="fc" id="L230">        try (InputStream stream = this.getClass().getResourceAsStream(&quot;/logback.html&quot;)) {</span>
<span class="fc" id="L231">          String newHtml = new String(stream.readAllBytes(), StandardCharsets.UTF_8);</span>
<span class="fc" id="L232">          this.htmlContents = newHtml;</span>
<span class="fc" id="L233">          promise.complete(newHtml);</span>
<span class="nc" id="L234">        } catch (Throwable ex) {</span>
<span class="nc" id="L235">          logger.error(&quot;Failed to load HTML: &quot;, ex);</span>
<span class="nc" id="L236">          getLogLevelsJson(response);</span>
<span class="fc" id="L237">        }</span>
<span class="fc" id="L238">      });</span>
    }
<span class="fc" id="L240">    loadFuture.map(html -&gt; html.replaceAll(&quot;URL&quot;, &quot;'&quot; + request.absoluteURI() + &quot;'&quot;))</span>
<span class="fc" id="L241">            .compose(html -&gt; {</span>
<span class="fc" id="L242">              response.putHeader(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
<span class="fc" id="L243">              response.setStatusCode(200);</span>
<span class="fc" id="L244">              response.end(html);</span>
<span class="fc" id="L245">              return Future.succeededFuture();</span>
            });
<span class="fc" id="L247">  }</span>

  private void updateLogLevel(String loggerName, HttpServerRequest request, HttpServerResponse response) {
<span class="fc" id="L250">    request.body()</span>
<span class="fc" id="L251">            .compose(buffer -&gt; {</span>
<span class="fc" id="L252">              JsonObject jo = buffer.toJsonObject();</span>
<span class="fc" id="L253">              String newLevel = jo.getString(&quot;level&quot;);</span>
<span class="fc" id="L254">              setLogLevel(loggerName, newLevel);</span>
<span class="fc" id="L255">              getLogLevelsJson(response);</span>
<span class="fc" id="L256">              return Future.succeededFuture();</span>
            });
    
<span class="fc" id="L259">  }</span>
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>